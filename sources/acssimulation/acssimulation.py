# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ar8txfi4R0-pcCuvDM2becOd4sKOCNFr
"""

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from sgp4.api import Satrec, jday
from wmm2020 import wmm
from datetime import datetime

# Configurações da órbita usando TLE
tle_line1 = "1 26818U 01023A   24312.03817633  .00000197  00000+0  19301-3 0  9997"
tle_line2 = "2 26818  82.9235 296.7582 0031690 241.7346 178.7972 13.74083894174270"
satellite = Satrec.twoline2rv(tle_line1, tle_line2)

# Parâmetros do CubeSat
mass = 1.0  # Massa em kg
inertia = np.diag([0.001, 0.001, 0.002])  # Momento de inércia em kg.m^2
orbital_period = 5400  # Aproximadamente 90 minutos em segundos

# Parâmetros do magnetorquer
N = 100
area = 1.5e-4  # Área da bobina em m^2 (diâmetro ~1.5cm)
current = 0.05  # Corrente máxima em A
moment_magnetic = np.array([N * area * current, 0, 0])  # Vetor de momento magnético 3D

# Função de torque gerado pelo magnetorquer
def torque_magnetorquer(magnetic_moment, B_field):
    return np.cross(magnetic_moment, B_field)

# Função para calcular o campo magnético da Terra com WMM2020
def earth_magnetic_field(lat, lon, alt_km):
    result = wmf0)  # Ano de referência 2020
    B_north, B_east, B_down = result['north'], result['east'], result['down']
    Bx = np.squeeze(B_north)
    By = np.squeeze(B_east)
    Bz = np.squeeze(-B_down)  # Inverte para que 'down' fique positivo no eixo Z
    return np.array([Bx, By, Bz]) * 1e-9  # Conversão para Tesla

# Equações de movimento
def attitude_dynamics(t, state):
    # Descompacta o estado
    w = state[0:3]  # Velocidade angular (rad/s)
    q = state[3:]   # Quatérnio de atitude

    # Calcula a posição e velocidade do satélite usando SGP4
    year, month, day, hour, minute, second = (2024, 1, 1, 0, 0, t)
    jd, fr = jday(year, month, day, hour, minute, second)
    e, pos, vel = satellite.sgp4(jd, fr)

    if e != 0:
        print(f"Erro na propagação orbital no tempo {t}: código {e}")
        return np.zeros(7)

    # Converte posição para latitude, longitude e altitude
    r_norm = np.linalg.norm(pos)
    alt_km = (r_norm - 6371.0)  # altitude em km
    lat, lon = np.degrees(np.arcsin(pos[2] / r_norm)), np.degrees(np.arctan2(pos[1], pos[0]))

    # Calcula o campo magnético da Terra em posição atual
    B_earth = earth_magnetic_field(lat, lon, alt_km)

    # Verificação de dimensão para B_earth
    if B_earth.shape != (3,):
        print(f"Erro: B_earth tem forma {B_earth.shape} ao invés de (3,). Valores de lat: {lat}, lon: {lon}, alt_km: {alt_km}")
        raise ValueError("B_earth não tem a dimensão esperada de 3 componentes.")

    # Momento magnético do magnetorquer
    m = np.array([moment_magnetic[0], moment_magnetic[1], moment_magnetic[2]])

    # Torque gerado pelo magnetorquer
    torque = torque_magnetorquer(m, B_earth)

    # Dinâmica rotacional: dw/dt = I^(-1) * (torque - w x (I * w))
    w_dot = np.linalg.inv(inertia).dot(torque - np.cross(w, inertia.dot(w)))

    # Atualização do quatérnio: dq/dt = 0.5 * q * w
    q_dot = 0.5 * np.array([
        -q[1]*w[0] - q[2]*w[1] - q[3]*w[2],
         q[0]*w[0] + q[2]*w[2] - q[3]*w[1],
         q[0]*w[1] - q[1]*w[2] + q[3]*w[0],
         q[0]*w[2] + q[1]*w[1] - q[2]*w[0]
    ])

    return np.concatenate([w_dot, q_dot])

# Estado inicial: velocidade angular (rad/s) e quatérnio inicial (sem rotação)
w0 = np.array([0.01, 0.01, 0.01])  # Velocidade angular inicial
q0 = np.array([1, 0, 0, 0])  # Quatérnio inicial (identidade)
state0 = np.concatenate([w0, q0])

# Simulação
t_span, t_eval = (0, 5400), np.linspace(0, 5400, 1000)
solution = solve_ivp(attitude_dynamics, t_span, state0, t_eval=t_eval, method='RK45')

# Plotagem da velocidade angular
plt.figure(figsize=(12, 6))
plt.plot(solution.t / 60, solution.y[0], label='w_x (rad/s)')
plt.plot(solution.t / 60, solution.y[1], label='w_y (rad/s)')
plt.plot(solution.t / 60, solution.y[2], label='w_z (rad/s)')
plt.xlabel('Tempo (min)')
plt.ylabel('Velocidade Angular (rad/s)')
plt.legend()
plt.title('Dinâmica da Velocidade Angular do CubeSat com ACS Passivo durante uma Órbita LEO')
plt.show()

# Plotagem dos quatérnios
plt.figure(figsize=(12, 6))
plt.plot(solution.t / 60, solution.y[3], label='q_0')
plt.plot(solution.t / 60, solution.y[4], label='q_1')
plt.plot(solution.t / 60, solution.y[5], label='q_2')
plt.plot(solution.t / 60, solution.y[6], label='q_3')
plt.xlabel('Tempo (min)')
plt.ylabel('Quatérnio')
plt.legend()
plt.title('Evolução dos Quatérnios do CubeSat com ACS Passivo durante uma Órbita LEO')
plt.show()